name: Build Windows64

# Inputs (some selected):
#   GITHUB_EVENT_NAME - the name of the event that triggered the workflow (e.g., push, pull_request, workflow_dispatch, etc.)
#   GITHUB_REF_TYPE - the type of ref that triggered the workflow (e.g., branch, tag)
#   GITHUB_REF - what triggered the workflow (e.g., refs/heads/branch_name, refs/tags/v1.0.0, refs/)
#   GITHUB_REF_NAME - the name of the branch or tag that triggered the workflow (e.g., branch_name, v1.0.0)
#   GITHUB_SHA - the commit SHA that triggered the workflow
#   GITHUB_WORKSPACE - the path to the repository on the runner . top level directory of the repository

# on:
#   GITHUB_EVENT_NAME
#     GITHUB_REF_TYPE


# !!! important:
#   - A single tag can point to multiple branches, so there isn't a single matching branch for a tag.
#   - deafult branch for workflow_dispatch is the default branch of the repository, which is usually 'main' or 'master'.
#     - may be set gh workflow run -r <branch> <workflow_file>
#   - variables ${{ xxx }} are parsed by YAML parser, before shell can see it ( eg ${{ $xxx }} is not what you expect).

on:
  push:
    # branches: [___]   # EVENT_NAME=push              REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
    tags:
      - build*          # EVENT_NAME=push              REF_TYPE=tag      REF=refs/tags/build*        REF_NAME=tag_name
      - v*.*.*          # EVENT_NAME=push              REF_TYPE=tag      REF=refs/tags/v*.*.*        REF_NAME=tag_name
  # pull_request:
  #   branches: [___]   # EVENT_NAME=pull_request      REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
  #   tags: [build*]    # EVENT_NAME=pull_request      REF_TYPE=tag      REF=refs/tags/build*        REF_NAME=tag_name
  workflow_dispatch:    # EVENT_NAME=workflow_dispatch REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name

# sign policy
#   push into branch     - create release dev-build-branch_name
#   push into tag v*.*.* - create release tag_name, signed, if secrets are not available exit 1 (or dev-build-tag_name?)
#                 build* - create release dev-build-tag_name, signed  or self signed

jobs:
  sign_policy:
    runs-on: ubuntu-latest
    outputs:
      MY_SELF_SIGNED: ${{ steps.set_vars.outputs.MY_SELF_SIGNED }}
      MY_TAG_NAME: ${{ steps.set_vars.outputs.MY_TAG_NAME }}
      MY_PRERELEASE: ${{ steps.set_vars.outputs.MY_PRERELEASE }}
      MY_NAME: ${{ steps.set_vars.outputs.MY_NAME }}
    # if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set sign policy variables
        id: set_vars
        shell: bash
        run: |

          echo "-------------------------------------------------"
          echo "Set signing policy variables ..."
          echo secrets.GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # print ***, always set

          echo "-------------------------------------------------"

          # this is just for testing, not needed in real workflow
          echo "Testing secrets:"
          echo secrets.MY_KEY1: ${{ secrets.MY_KEY1 }}  # is set
          echo secrets.MY_KEY2: ${{ secrets.MY_KEY2 }}  # is " " one space, empty string can't be set in GitHub secrets
          echo secrets.MY_KEY3: ${{ secrets.MY_KEY3 }}  # is not set

          echo "-------------------------------------------------"
          # inputs
          echo "Inputs:"
          # echo "tag_name: ${{ github.event.inputs.tag_name }}"  # ref: github.event.inputs.tag_name


          echo "-------------------------------------------------"
          # Check if secrets are available
          if [[ -n "${{ secrets.MY_KEY1 }}" ]]; then
            MY_SELF_SIGNED=false      # we have access to secrets
          else
            MY_SELF_SIGNED=true       # we use on the fly signed keys
          fi

          echo "-------------------------------------------------"

          # *** release requires tag name
          # if push tag vX.X.X - release sign-policy, not v.X.X.X.alpha-xxx ...
          if [[ "${EVENT_NAME}" == "push" && \
                "${GITHUB_REF_TYPE}" == "tag" && \
                "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+* ]]; then
            MY_TAG_NAME="${GITHUB_REF_NAME}"
            MY_PRERELEASE=false  # we are creating a release
            MY_NAME="${MY_TAG_NAME}"
          else
            MY_TAG_NAME="dev-build-$(echo $GITHUB_REF_NAME | tr / -)"  # use branch/tag name as tag, replace / with -
            MY_PRERELEASE=true   # we are creating a pre-release
            MY_NAME="development build of ${GITHUB_REF_NAME}"
          fi

          # if Release doesn't have access to secrets exit with error
          if [[ "${MY_PRERELEASE}" == "false" && "${MY_SELF_SIGNED}" == "false" ]]; then
            echo "Error: Cannot create a release without access to secrets."
            exit 1
          fi


          echo "------------------------------------------------- echoing variables"
          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}"
          echo "MY_TAG_NAME=${MY_TAG_NAME}"
          echo "MY_PRERELEASE=${MY_PRERELEASE}"
          echo "MY_NAME=${MY_NAME}"

          echo "------------------------------------------------- Exporting variables to GITHUB_OUTPUT"
          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}" >> $GITHUB_OUTPUT
          echo "MY_TAG_NAME=${MY_TAG_NAME}" >> $GITHUB_OUTPUT
          echo "MY_PRERELEASE=${MY_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "MY_NAME=${MY_NAME}" >> $GITHUB_OUTPUT

          echo "-------------------------------------------------"
          env | sort | grep GITHUB_


  # ---------------------------------------------------------------------------------------------------
  build:
    needs: sign_policy
    runs-on: windows-latest

    env:
      MY_SELF_SIGNED: ${{ needs.sign_policy.outputs.MY_SELF_SIGNED }}
      MY_TAG_NAME: ${{ needs.sign_policy.outputs.MY_TAG_NAME }}
      MY_PRERELEASE: ${{ needs.sign_policy.outputs.MY_PRERELEASE }}
      MY_NAME: ${{ needs.sign_policy.outputs.MY_NAME }}

    steps:
      - name: env variables MY_xxx
        shell: cmd
        run: |

          echo MY_SELF_SIGNED=%MY_SELF_SIGNED%
          echo MY_TAG_NAME=%MY_TAG_NAME%
          echo MY_PRERELEASE=%MY_PRERELEASE%
          echo MY_NAME=%MY_NAME%

      - name: Checkout repo
        uses: actions/checkout@v4

      # 'C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin' # Path to MSBuild
      - name: Install msbuild # https://github.com/microsoft/setup-msbuild
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: 'latest' # Specify the version of Visual Studio to use or "latest" for the latest version



      # - name: Setup Git for Windows SDK # https://github.com/git-for-windows/setup-git-for-windows-sdk
      #   uses: git-for-windows/setup-git-for-windows-sdk@v1
      #   with:
      #     flavor: minimal
      #     # flavor: build-installers



      - name: Dynamically find vcvarsall.bat (PowerShell)
        id: find-vcvarsall
        shell: pwsh
        run: |

          # Use vswhere.exe to find the path to the latest VS installation
          $vsInstallPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -property installationPath

          if (-not $vsInstallPath) {
            Write-Error "Visual Studio installation path not found using vswhere.exe."
            exit 1
          }

          # Construct the full path to vcvarsall.bat
          $vcvarsallPath = Join-Path $vsInstallPath "VC\Auxiliary\Build\vcvarsall.bat"

          if (-not (Test-Path $vcvarsallPath)) {
            Write-Error "vcvarsall.bat not found at '$vcvarsallPath'."
            exit 1
          }

          Write-Host "Found vcvarsall.bat at: $vcvarsallPath"

          # You can save this path as an environment variable for subsequent steps
          echo "VC_VARS_PATH=$vcvarsallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "VS_INSTALL_PATH=$vsInstallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append


      - name: Print environment variables (cmd)
        shell: cmd
        run: |

          echo VS_INSTALL_PATH=%VS_INSTALL_PATH%
          echo VC_VARS_PATH=%VC_VARS_PATH%
          echo PATH=%PATH%


      - name: run clrver (only for cmd, not working for pwsh)
        # check if clrver.exe is available on the PATH, then all should be fine
        shell: cmd
        run: |

          CALL "${{ env.VC_VARS_PATH }}" x64
          :: clrver.exe is part of the .NET SDK, which is pre-installed on Windows runners
          clrver
          :: signtool.exe is part of the Windows SDK, which is pre-installed on Windows runners
          :: signtool /v


      - name: Print environment & PowerShell version
        shell: pwsh
        run: |

          $PSVersionTable | Format-List
          Get-ChildItem Env: | Sort-Object Name | Format-Table -AutoSize


      - name: Compile main.cpp
        shell: cmd # smd or pwsh
        run: |

          :: Set up the environment for Visual Studio
          CALL "${{ env.VC_VARS_PATH }}" x64
          WHERE cl.exe
          :: Fe - name of output file
          cl main.cpp /Fe:main.exe


      - name: List files in current directory
        shell: cmd
        run: dir

      - name: Upload unsigned executable as artifact
        uses: actions/upload-artifact@v4   # https://github.com/actions/upload-artifact
        with:
          name: compiled-unsigned   # where to copy - unique through workflow
          path: main.exe


      # Generate a self-signed certificate, sign the executable, and verify the signature
      # Using PowerShell is recommended for this task as it provides better control and flexibility.
      - name: Generate Self-Signed Certificate, Sign and Verify (Pure PowerShell)
        id: generate-sign-verify
        shell: pwsh # Explicitly specify PowerShell

        run: |

          # Ensure VC_VARS_PATH is correctly set from a previous step via GITHUB_ENV. - not needed
          # & "${{ env.VC_VARS_PATH }}" x64

          # --- Variable Setup ---
          # My self-signed certificate name (CN) for testing purposes
          $certName = "MyTestSigningCert-$(Get-Date -Format 'yyyyMMdd-HHmmss')"

          # ConvertTo-SecureString
          #   https://learn.microsoft.com/powershell/module/microsoft.powershell.security/convertto-securestring
          #  - (New-Guid).ToString() generates a new GUID, which is a   good choice for a secure password.
          #  - AsPlainText: input string is already in plain text (no need to decrypt)
          #  - Convert plain text password to a secure string (simply convert string to secure string in .NET)
          $pfxPassword = ConvertTo-SecureString -String (New-Guid).ToString() -AsPlainText -Force
          $pfxPath = "$($env:TEMP)\$($certName).pfx"
          $fileToSign = "main.exe" # Assumes main.exe already exists from your compilation step
          $timestampServer = "http://timestamp.digicert.com" # Timestamp server URL


          Write-Host "--- Step 1: Generating Self-Signed Certificate ---"
          Write-Host "Generating self-signed certificate: $certName"
          # 1. Generate the self-signed certificate
          #  https://learn.microsoft.com/powershell/module/pki/new-selfsignedcertificate
          # -CertStoreLocation Cert:\CurrentUser\My : Stores the certificate in the current user's certificate store
          # -Type CodeSigning : Specifies the certificate's purpose as code signing
          # -Subject "CN=$certName" : Sets the common name of the certificate
          # -KeyAlgorithm RSA -KeyLength 2048 : Sets key parameters
          # -NotAfter (Get-Date).AddDays(7) : Certificate valid for 7 days (sufficient for testing)
          # -KeyUsage DigitalSignature : Key usage for digital signatures
          # -HashAlgorithm SHA256 : Hashing algorithm for the signature
          $param = @{
              CertStoreLocation = 'Cert:\CurrentUser\My'
              Type = 'CodeSigning'
              Subject = "CN=$certName"
              KeyAlgorithm = 'RSA'
              KeyLength = 2048
              NotAfter = (Get-Date).AddDays(7)  # valid for 7 days
              KeyUsage = 'DigitalSignature'
              HashAlgorithm = 'SHA256'
          }
          # Create the self-signed certificate
          $cert = New-SelfSignedCertificate @param


          Write-Host "Certificate generated with thumbprint: $($cert.Thumbprint)"

          Write-Host "--- Step 2: Certificate details:"
          # Display certificate details
          # https://learn.microsoft.com/powershell/module/microsoft.powershell.management/get-childitem
          Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert

          Write-Host "--- Step 3: Sign code with the generated certificate: $certName"
          # https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature
          $param = @{
              FilePath = $fileToSign
              Certificate = $cert  # Use the certificate object we just generated
          }
          Set-AuthenticodeSignature @param


          # Rename main.exe to main-signed.exe
          Write-Host "--- Step 4: Renaming signed file to main-signed.exe"
          $signedFileName = "main-signed.exe"
          Rename-Item -Path $fileToSign -NewName $signedFileName
          Write-Host "Signed file renamed to: $signedFileName"

          Write-Host "All operations completed successfully."

      - name: List files in current directory
        shell: cmd
        run: dir


      - name: Upload signed executable as artifact
        uses: actions/upload-artifact@v4  # https://github.com/actions/upload-artifact
        with:
          # copy main-signed.exe to artifact, no special characters in name !!!
          name: compiled-selfsigned
          path: main-signed.exe


  release:
    needs:
      - build
      - sign_policy
    runs-on: ubuntu-latest

    env:
      MY_SELF_SIGNED: ${{ needs.sign_policy.outputs.MY_SELF_SIGNED }}
      MY_TAG_NAME: ${{ needs.sign_policy.outputs.MY_TAG_NAME }}
      MY_PRERELEASE: ${{ needs.sign_policy.outputs.MY_PRERELEASE }}
      MY_NAME: ${{ needs.sign_policy.outputs.MY_NAME }}


    steps:
      - name: List MY_xxx variables
        shell: bash
        run: |

          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}"
          echo "MY_TAG_NAME=${MY_TAG_NAME}"
          echo "MY_PRERELEASE=${MY_PRERELEASE}"
          echo "MY_NAME=${MY_NAME}"


      # get files from artifacts
      - name: Download artifacts from build job
        uses: actions/download-artifact@v4    # https://github.com/actions/download-artifact
        with:
        #   name: .. # default is all artifacts
          path: artifacts  # download to artifacts directory


      - name: List files in artifacts directory
        shell: bash
        run: |

          echo "Listing files in artifacts directory:"
          ls -lR artifacts


      - name: Create release
        id: create_release
        uses: softprops/action-gh-release@v1  # https://github.com/softprops/action-gh-release
        with:
          # token: ${{ secrets.GITHUB_TOKEN }}  # always set, used to create release
          tag_name: ${{ env.MY_TAG_NAME }}
          name: ${{ env.MY_NAME }}
          prerelease: ${{ env.MY_PRERELEASE }}
          draft: false
          body: |
            This is a release for ${{ env.MY_NAME }}.
            - Self-signed: ${{ env.MY_SELF_SIGNED }}
            - Tag name: ${{ env.MY_TAG_NAME }}
            - Pre-release: ${{ env.MY_PRERELEASE }}
          files: |
            artifacts/**/*
          #   artifacts/compiled-selfsigned/main.exe
          #   # artifacts/compiled-unsigned/main.exe  # all files must have different names, we can't upload both


