name: Build Windows64

# Inputs (some selected):
#   GITHUB_EVENT_NAME - the name of the event that triggered the workflow (e.g., push, pull_request, workflow_dispatch, etc.)
#   GITHUB_REF_TYPE - the type of ref that triggered the workflow (e.g., branch, tag)
#   GITHUB_REF - what triggered the workflow (e.g., refs/heads/branch_name, refs/tags/v1.0.0, refs/)
#   GITHUB_REF_NAME - the name of the branch or tag that triggered the workflow (e.g., branch_name, v1.0.0)
#   GITHUB_SHA - the commit SHA that triggered the workflow
#   GITHUB_WORKSPACE - the path to the repository on the runner . top level directory of the repository

# on:
#   GITHUB_EVENT_NAME
#     GITHUB_REF_TYPE


# !!! important:
#   - A single tag can point to multiple branches, so there isn't a single matching branch for a tag.
#   - deafult branch for workflow_dispatch is the default branch of the repository, which is usually 'main' or 'master'.
#     - may be set gh workflow run -r <branch> <workflow_file>

on:
  push:
    # branches: [___]   # EVENT_NAME=push              REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
    tags:
      - build*          # EVENT_NAME=push              REF_TYPE=tag      REF=refs/tags/build*        REF_NAME=tag_name
      - v*.*.*          # EVENT_NAME=push              REF_TYPE=tag      REF=refs/tags/v*.*.*        REF_NAME=tag_name
  # pull_request:
  #   branches: [___]   # EVENT_NAME=pull_request      REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
  #   tags: [build*]    # EVENT_NAME=pull_request      REF_TYPE=tag      REF=refs/tags/build*        REF_NAME=tag_name
  workflow_dispatch:    # EVENT_NAME=workflow_dispatch REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
    inputs:
      tag_name:                   # ref: github.event.inputs.build_type | inputs.build_type
        description: 'create a release tag with this name'  # description of the input
        required: true
        default: 'dev-build'  # default value
        type: string  # type of the input, can be number, boolean, string, choice or environment

# sign policy before build
#   push into branch     - create release dev-build-branch_name
#   push into tag v*.*.* - create release tag_name, signed, if secrets are not available dev-build-tag_name
#                 build* - create release dev-build-tag_name, self signed

jobs:
  sign_policy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Sign policy
        shell: bash
        run: |

          echo "-------------------------------------------------"
          echo "Signing policy..."
          echo secrets.GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # print ***, always set

          echo "-------------------------------------------------"

          echo secrets.MY_KEY1: ${{ secrets.MY_KEY1 }}  # is set
          echo secrets.MY_KEY2: ${{ secrets.MY_KEY2 }}  # is " " one space, empty string can't be set in GitHub secrets
          echo secrets.MY_KEY3: ${{ secrets.MY_KEY3 }}  # is not set

          echo "-------------------------------------------------"
          # inputs
          echo "tag_name: ${{ github.event.inputs.tag_name }}"  # ref: github.event.inputs.tag_name


          echo "-------------------------------------------------"
          # Check if secrets are available
          if [[ -n "${{ secrets.MY_KEY1 }}" ]]; then
            MY_SELF_SIGNED=false      # we have access to secrets
          else
            MY_SELF_SIGNED=true       # we use on the fly signed keys
          fi
          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}"

          echo "-------------------------------------------------"

          # *** release requires tag name
          # if push tag vX.X.X - release sign-policy, not v.X.X.X.alpha-xxx ...
          if [[ "${EVENT_NAME}" == "push" && \
                "${GITHUB_REF_TYPE}" == "tag" && \
                "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            MY_TAG_NAME="${GITHUB_REF_NAME}"
            MY_PRERELEASE=false  # we are creating a release
            MY_NAME="${MY_TAG_NAME}"
          else
            MY_TAG_NAME="dev-build-$(echo $GITHUB_REF_NAME | tr / -)"  # use branch name as tag
            MY_PRERELEASE=true   # we are creating a pre-release
            MY_NAME="development build of  ${GITHUB_REF_NAME}"
          fi

          echo "-------------------------------------------------"

          echo "MY_TAG_NAME=${MY_TAG_NAME}"
          echo "MY_PRERELEASE=${MY_PRERELEASE}"
          echo "MY_NAME=${MY_NAME}"

          echo "-------------------------------------------------"
          env | sort | grep GITHUB_


  build:
    needs: sign_policy
    runs-on: windows-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # 'C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin' # Path to MSBuild
      - name: Install msbuild # https://github.com/microsoft/setup-msbuild
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: 'latest' # Specify the version of Visual Studio to use or "latest" for the latest version



      # - name: Setup Git for Windows SDK # https://github.com/git-for-windows/setup-git-for-windows-sdk
      #   uses: git-for-windows/setup-git-for-windows-sdk@v1
      #   with:
      #     flavor: minimal
      #     # flavor: build-installers



      - name: Dynamically find vcvarsall.bat (PowerShell)
        id: find-vcvarsall
        shell: pwsh
        run: |

          # Use vswhere.exe to find the path to the latest VS installation
          $vsInstallPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -property installationPath

          if (-not $vsInstallPath) {
            Write-Error "Visual Studio installation path not found using vswhere.exe."
            exit 1
          }

          # Construct the full path to vcvarsall.bat
          $vcvarsallPath = Join-Path $vsInstallPath "VC\Auxiliary\Build\vcvarsall.bat"

          if (-not (Test-Path $vcvarsallPath)) {
            Write-Error "vcvarsall.bat not found at '$vcvarsallPath'."
            exit 1
          }

          Write-Host "Found vcvarsall.bat at: $vcvarsallPath"

          # You can save this path as an environment variable for subsequent steps
          echo "VC_VARS_PATH=$vcvarsallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "VS_INSTALL_PATH=$vsInstallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append


      - name: Print environment variables (cmd)
        shell: cmd
        run: |

          echo VS_INSTALL_PATH=%VS_INSTALL_PATH%
          echo VC_VARS_PATH=%VC_VARS_PATH%
          echo PATH=%PATH%


      - name: run clrver (only for cmd, not working for pwsh)
        # check if clrver.exe is available on the PATH, then all should be fine
        shell: cmd
        run: |

          CALL "${{ env.VC_VARS_PATH }}" x64
          :: clrver.exe is part of the .NET SDK, which is pre-installed on Windows runners
          clrver
          :: signtool.exe is part of the Windows SDK, which is pre-installed on Windows runners
          :: signtool /v


      - name: Print environment & PowerShell version
        shell: pwsh
        run: |

          $PSVersionTable | Format-List
          Get-ChildItem Env: | Sort-Object Name | Format-Table -AutoSize


      - name: Compile main.cpp
        shell: cmd # smd or pwsh
        run: |

          :: Set up the environment for Visual Studio
          CALL "${{ env.VC_VARS_PATH }}" x64
          WHERE cl.exe
          :: Fe - name of output file
          cl main.cpp /Fe:main.exe


      - name: List files in current directory
        shell: cmd
        run: dir

      - name: Upload unsigned executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: compiled-unsigned   # copy main.exe to artifact/compiled-unsigned.zip
          path: main.exe


      # Generate a self-signed certificate, sign the executable, and verify the signature
      # Using PowerShell is recommended for this task as it provides better control and flexibility.
      - name: Generate Self-Signed Certificate, Sign and Verify (Pure PowerShell)
        id: generate-sign-verify
        shell: pwsh # Explicitly specify PowerShell

        run: |

          # Ensure VC_VARS_PATH is correctly set from a previous step via GITHUB_ENV. - not needed
          # & "${{ env.VC_VARS_PATH }}" x64

          # --- Variable Setup ---
          # My self-signed certificate name (CN) for testing purposes
          $certName = "MyTestSigningCert-$(Get-Date -Format 'yyyyMMdd-HHmmss')"

          # ConvertTo-SecureString
          #   https://learn.microsoft.com/powershell/module/microsoft.powershell.security/convertto-securestring
          #  - (New-Guid).ToString() generates a new GUID, which is a   good choice for a secure password.
          #  - AsPlainText: input string is already in plain text (no need to decrypt)
          #  - Convert plain text password to a secure string (simply convert string to secure string in .NET)
          $pfxPassword = ConvertTo-SecureString -String (New-Guid).ToString() -AsPlainText -Force
          $pfxPath = "$($env:TEMP)\$($certName).pfx"
          $fileToSign = "main.exe" # Assumes main.exe already exists from your compilation step
          $timestampServer = "http://timestamp.digicert.com" # Timestamp server URL


          Write-Host "--- Step 1: Generating Self-Signed Certificate ---"
          Write-Host "Generating self-signed certificate: $certName"
          # 1. Generate the self-signed certificate
          #  https://learn.microsoft.com/powershell/module/pki/new-selfsignedcertificate
          # -CertStoreLocation Cert:\CurrentUser\My : Stores the certificate in the current user's certificate store
          # -Type CodeSigning : Specifies the certificate's purpose as code signing
          # -Subject "CN=$certName" : Sets the common name of the certificate
          # -KeyAlgorithm RSA -KeyLength 2048 : Sets key parameters
          # -NotAfter (Get-Date).AddDays(7) : Certificate valid for 7 days (sufficient for testing)
          # -KeyUsage DigitalSignature : Key usage for digital signatures
          # -HashAlgorithm SHA256 : Hashing algorithm for the signature
          $param = @{
              CertStoreLocation = 'Cert:\CurrentUser\My'
              Type = 'CodeSigning'
              Subject = "CN=$certName"
              KeyAlgorithm = 'RSA'
              KeyLength = 2048
              NotAfter = (Get-Date).AddDays(7)
              KeyUsage = 'DigitalSignature'
              HashAlgorithm = 'SHA256'
          }
          # Create the self-signed certificate
          $cert = New-SelfSignedCertificate @param


          Write-Host "Certificate generated with thumbprint: $($cert.Thumbprint)"

          Write-Host "--- Step 2: Certificate details:"
          # Display certificate details
          # https://learn.microsoft.com/powershell/module/microsoft.powershell.management/get-childitem
          Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert

          Write-Host "--- Step 3: Sign code with the generated certificate: $certName"
          $param = @{
              FilePath = $fileToSign
              Certificate = $cert  # Use the certificate object we just generated
          }
          Set-AuthenticodeSignature @param


          Write-Host "All operations completed successfully."

      - name: List files in current directory
        shell: cmd
        run: dir


      - name: Upload signed executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: compiled-selfsigned   # copy main.exe to artifact/compiled-selfsigned.zip
          path: main.exe
