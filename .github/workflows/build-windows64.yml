name: Build Windows64

on:
  push:
    tags: [build*]
  workflow_dispatch:


jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # 'C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin' # Path to MSBuild
      - name: Install msbuild # https://github.com/microsoft/setup-msbuild
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: 'latest' # Specify the version of Visual Studio to use or "latest" for the latest version



      # - name: Setup Git for Windows SDK # https://github.com/git-for-windows/setup-git-for-windows-sdk
      #   uses: git-for-windows/setup-git-for-windows-sdk@v1
      #   with:
      #     flavor: minimal
      #     # flavor: build-installers



      - name: Dynamically find vcvarsall.bat (PowerShell)
        id: find-vcvarsall
        shell: pwsh
        run: |

          # Use vswhere.exe to find the path to the latest VS installation
          $vsInstallPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -property installationPath

          if (-not $vsInstallPath) {
            Write-Error "Visual Studio installation path not found using vswhere.exe."
            exit 1
          }

          # Construct the full path to vcvarsall.bat
          $vcvarsallPath = Join-Path $vsInstallPath "VC\Auxiliary\Build\vcvarsall.bat"

          if (-not (Test-Path $vcvarsallPath)) {
            Write-Error "vcvarsall.bat not found at '$vcvarsallPath'."
            exit 1
          }

          Write-Host "Found vcvarsall.bat at: $vcvarsallPath"

          # You can save this path as an environment variable for subsequent steps
          echo "VC_VARS_PATH=$vcvarsallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "VS_INSTALL_PATH=$vsInstallPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append


      - name: Print environment variables (cmd)
        shell: cmd
        run: |

          echo VS_INSTALL_PATH=%VS_INSTALL_PATH%
          echo VC_VARS_PATH=%VC_VARS_PATH%

      - name: Print full PATH (cmd)
        shell: cmd
        run: |
          echo %PATH%


      - name: run clrver (only for cmd, not working for pwsh)
        # check if clrver.exe is available on the PATH, then all should be fine
        shell: cmd
        run: |

          CALL "${{ env.VC_VARS_PATH }}" x64
          :: clrver.exe is part of the .NET SDK, which is pre-installed on Windows runners
          clrver
          :: signtool.exe is part of the Windows SDK, which is pre-installed on Windows runners
          :: signtool /v


      - name: Print environment & PowerShell version
        shell: pwsh
        run: |

          $PSVersionTable | Format-List
          Get-ChildItem Env: | Sort-Object Name | Format-Table -AutoSize


      - name: Compile main.cpp
        shell: cmd # smd or pwsh
        run: |

          :: Set up the environment for Visual Studio
          CALL "${{ env.VC_VARS_PATH }}" x64
          WHERE cl.exe
          :: Fe - name of output file
          cl main.cpp /Fe:main.exe


      - name: List files in current directory
        shell: cmd
        run: dir

      - name: Upload unsigned executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: compiled-unsigned   # auto zip file
          path: main.exe



      - name: Generate Self-Signed Certificate, Sign and Verify (Pure PowerShell)
        id: generate-sign-verify
        shell: pwsh # Explicitly specify PowerShell

        run: |

          # Important: Set up the MSVC environment.
          # This step is still necessary if other steps (outside this one) use MSVC tools (e.g., cl.exe).
          # Ensure VC_VARS_PATH is correctly set from a previous step via GITHUB_ENV.
          # & "${{ env.VC_VARS_PATH }}" x64

          # --- Variable Setup ---
          $certName = "MyTestSigningCert-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
          # Generate a random, secure password for the PFX file
          $pfxPassword = ConvertTo-SecureString -String (New-Guid).ToString() -AsPlainText -Force
          $pfxPath = "$($env:TEMP)\$($certName).pfx"
          $fileToSign = "main.exe" # Assumes main.exe already exists from your compilation step
          $timestampServer = "http://timestamp.digicert.com" # Timestamp server URL

          Write-Host "--- Step 1: Generating Self-Signed Certificate ---"
          Write-Host "Generating self-signed certificate: $certName"
          # 1. Generate the self-signed certificate
          # -CertStoreLocation Cert:\CurrentUser\My : Stores the certificate in the current user's certificate store
          # -Type CodeSigning : Specifies the certificate's purpose as code signing
          # -Subject "CN=$certName" : Sets the common name of the certificate
          # -KeyAlgorithm RSA -KeyLength 2048 : Sets key parameters
          # -NotAfter (Get-Date).AddDays(7) : Certificate valid for 7 days (sufficient for testing)
          # -KeyUsage DigitalSignature : Key usage for digital signatures
          # -HashAlgorithm SHA256 : Hashing algorithm for the signature
          $cert = New-SelfSignedCertificate `
              -CertStoreLocation Cert:\CurrentUser\My `
              -Type CodeSigning `
              -Subject "CN=$certName" `
              -KeyAlgorithm RSA `
              -KeyLength 2048 `
              -NotAfter (Get-Date).AddDays(7) `
              -KeyUsage DigitalSignature `
              -HashAlgorithm SHA256

          Write-Host "Certificate generated with thumbprint: $($cert.Thumbprint)"

          Write-Host "--- Step 2: Exporting Certificate to PFX File ---"
          # 2. Export the certificate with its private key to a PFX file
          # -FilePath $pfxPath : Path for the PFX file
          # -Password $pfxPassword : Password for the PFX file
          Export-PfxCertificate `
              -Cert $cert `
              -FilePath $pfxPath `
              -Password $pfxPassword

          Write-Host "PFX file exported to: $pfxPath"


          # --- NEW STEP: Import the self-signed certificate into the Trusted Root store ---
          Write-Host "--- Step 2.5: Importing self-signed cert to Trusted Root Certification Authorities (LocalMachine) ---"
          # This is necessary for the system to trust the self-signed certificate for verification.
          try {
              # $cert | Import-Certificate -CertStoreLocation Cert:\LocalMachine\Root -ErrorAction Stop
              Import-Certificate -Filepath $cert -CertStoreLocation Cert:\LocalMachine\Root
              Write-Host "Certificate imported to LocalMachine\Root store."
          }
          catch {
              Write-Error "Failed to import certificate to LocalMachine\Root: $($_.Exception.Message)"
              exit 1 # Exit the workflow on import error
          }


          Write-Host "--- Step 3: Signing the File using Set-AuthenticodeSignature ---"
          Write-Host "Signing file '$fileToSign' using Set-AuthenticodeSignature..."
          try {
              Set-AuthenticodeSignature `
                  -FilePath "$fileToSign" `
                  -Certificate $cert  # Use the certificate object we just generated
                  # -HashAlgorithm SHA256 ` # File digest algorithm
                  # -TimestampServer "$timestampServer" ` # Timestamp server URL
                  # -ErrorAction Stop # Important: Stops the script on any signing error

              Write-Host "File '$fileToSign' signed successfully using Set-AuthenticodeSignature."
          }
          catch {
              Write-Error "Set-AuthenticodeSignature failed: $($_.Exception.Message)"
              exit 1 # Exit the workflow on error
          }

          Write-Host "--- Step 4: Verifying the Signature using Get-AuthenticodeSignature ---"
          Write-Host "Verifying signature of file '$fileToSign'..."
          try {
              $signature = Get-AuthenticodeSignature -FilePath "$fileToSign" -ErrorAction Stop

              if ($signature.Status -eq 'Valid') {
                  Write-Host "Signature is VALID. Signed by: $($signature.SignerCertificate.Subject)"
              } else {
                  Write-Error "Signature is INVALID. Status: $($signature.Status) - Error: $($signature.StatusMessage)"
                  exit 1 # Exit the workflow if signature is not valid
              }
          }
          catch {
              Write-Error "Get-AuthenticodeSignature failed during verification: $($_.Exception.Message)"
              exit 1 # Exit the workflow on verification error
          }


          Write-Host "--- Step 5: Cleanup ---"
          Write-Host "Cleaning up generated certificate and PFX file..."
          Remove-Item $pfxPath -Force
          # Remove the certificate from the current user's store, including its private key
          Remove-Item "Cert:\CurrentUser\My\$($cert.Thumbprint)" -DeleteKey -Force
          # --- IMPORTANT: Remove the certificate from the Trusted Root store after completion! ---
          Write-Host "Removing certificate from LocalMachine\Root store..."
          try {
              Remove-Item "Cert:\LocalMachine\Root\$($cert.Thumbprint)" -DeleteKey -Force -ErrorAction Stop
              Write-Host "Certificate removed from LocalMachine\Root store."
          }
          catch {
              Write-Error "Failed to remove certificate from LocalMachine\Root: $($_.Exception.Message)"
              # We don't exit the workflow here, as it's just cleanup and the main part has already finished.
          }


          Write-Host "All operations completed successfully."


      - name: Upload signed executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: compiled-signed   # auto zip file
          path: main.exe
